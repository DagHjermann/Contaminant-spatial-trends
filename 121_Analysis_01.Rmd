---
title: "121 Analysis 01"
author: "DHJ"
date: "6 5 2020"
output: 
  html_document:
    keep_md: true
    toc: true
    toc_float: true 
    code_folding: hide
---

Based on script 120 (but extended a lot)   

**Highlights:**    
* *5. linear models* (function 'analysis_one_par')  
* 5a. Linear model - non-impacted stations   
    - using data set 'dat2_notimpacted' as input  
* 5b. Linear model - 'less-impacted' stations 
    -  difference in the code is only that we use data set 'dat2_lessimpacted' as input to 'analysis_one_par'  
    - this means all stations except Oslo + Sørfjorden  
* *7. Non-linear models (GAMM)* (function 'gamm_one_par_one_repl')  
* 7a. Additive GAMM - all stations       
* 7b. Additive GAMM - non-impacted stations  
* 7c. Additive GAMM - 'less-impacted' stations  
* 9.  Combine linear + non-linear results in table    
* *10. Non-linear models with interaction* (function 'gamm_one_par_one_repl' with 'interaction = TRUE')  
* 10. Non-linear models with interaction - all stations      
   
**Saved results:**    
* 5a "Data/121_result_list_notimpacted.rds"  
* 5b "Data/121_result_list_lessimpacted.rds"  
* 7a "Data/121_gamm_list0.rds"  
* 7b "Data/121_gamm_list1.rds"  
* 7c "Data/121_gamm_list2.rds"  
* 10 "Data/121_gamm_list_notimpacted_int.rds"  


## 1. Libraries  
```{r, message=FALSE, warning=FALSE, results='hide'}


library(rlang)

library(devtools)
library(lme4)
# library(usethis)
library(dplyr)
library(tidyr)
library(purrr)
library(forcats)
library(ggplot2)
library(mgcv)
library(visreg)

# devtools::install_github("moodymudskipper/safejoin")
library(safejoin)

# devtools::install_github("lenz99-/lme4cens")
library(lme4cens)

# For SpatialPoints() function in part 2, used for map in part 8
library(sp)

# For combining plots
library(cowplot)

# For nicer tables
library(knitr)
library(kableExtra)

# For get_point_on_coastline()
# Used in part 8  
source("103_Distance_along_coast_functions.R")
source("121_Analysis_01_functions.R")

```







## 2. Data   
Note that we get stations from script 103  
```{r, results = 'hold'}
# Data including trophic level
dat <- readRDS("Data/104_Selected_data.rds")
  
cat("Read data from script 104 \n")

# Extra isotope data
dat_isotopes <- readRDS("K:/Avdeling/214-Oseanografi/DHJ/Data/Contaminants/Marine/Milkys/87_df_isotopes.rds")

# Station metadata
df_stations <- readRDS("Data/103_Selected_stations.rds")




# xtabs(~STATION_CODE, df_stations ) %>% sort()
df_stations <- df_stations %>%
  mutate(MSTAT = case_when(
    STATION_CODE %in% "I969" ~ "RH",
    TRUE ~ MSTAT)) %>%
  group_by(STATION_CODE, MSTAT) %>%
  summarise_at(vars("Lat", "Lon", "Dist_along_coast"), mean)

check <- df_stations %>%
  group_by(STATION_CODE) %>%
  mutate(n = n()) %>%
  filter(n > 1)

if (nrow(check) > 0){
  cat("Some stations have >1 MSTAT codes - check 'check'! \n")
}
  
```

#### Checking
```{r}

if (FALSE){

  # OCS og «Oktaklorstyren (OCS)
  dat %>%
    filter(grepl("OCS", PARAM)) %>%
    xtabs(~PARAM + MYEAR, .)
  dat %>%
    filter(grepl("Oktaklor", PARAM)) %>%
    xtabs(~PARAM + MYEAR, .)

  # QCB og «Pentaklorbenzen (QCB)»
  dat %>%
    filter(grepl("QCB", PARAM)) %>%
    xtabs(~PARAM + MYEAR, .)

    }
```

### Parameter metadata (for sorting)  
Define `df_parameter_groups` 
```{r}

df_parameter_groups <- get_df_parameter_groups()

check <- df_parameter_groups %>%
  filter(is.na(Substance.Group)) %>%
  select(Parameter.Code,Substance.Group)

cat("Number of parameters lacking parameter group:", nrow(check), "\n")

```


### Isotopes in 'dat'   
Already added in script 104.  
  
It is not that easy as we heading out at here, since we need to couple isotopes (given for muscle) to 
chemical data (usually given for liver). See script 87 in `Milkys` project instead  

```{r}

if (FALSE){
  
  dat %>%
    filter(PARAM %in% c("Delta13C", "Delta15N") & MYEAR >= 2014) %>%
    xtabs(~MYEAR, .)
  
  #dat %>%
  #  filter(PARAM %in% c("Delta13C", "Delta15N") & MYEAR >= 2014) %>% View()
  
  dat %>%
    filter(PARAM %in% c("Delta13C", "Delta15N") & MYEAR >= 2014) %>%
    select(MYEAR, STATION_CODE, TISSUE_NAME, SAMPLE_NO2, PARAM, VALUE_WW) %>%
    tidyr::pivot_wider(names_from = PARAM, values_from = VALUE_WW) %>%
    arrange(MYEAR, STATION_CODE, TISSUE_NAME, SAMPLE_NO2)
  
}

```



### dat2 - combined data  
Adding
- position data + MSTAT (type of station - industry-impacted, representative or background)  
- LOQ  
- mean trophic level per station  

```{r}

# Median LOQ (per year and tissue only - should be the same for all stations)
dat_param_loq <- dat %>%
  filter(!is.na(FLAG1)) %>%
  group_by(PARAM, MYEAR, TISSUE_NAME) %>%
  summarise(LOQ = median(VALUE_WW))

dat2 <- dat %>%
  filter(!is.na(VALUE_WW)) %>%
  ungroup() %>%
  # Add position data + MSTAT (type of station - industry-impacted, representative or background)
  safe_left_join(df_stations %>% 
                   select(STATION_CODE, Lat, Lon, Dist_along_coast, MSTAT),
                 check = "CV",
                 by = "STATION_CODE",
                 na_matches = "never") %>%
  # Add LOQ
  safe_left_join(dat_param_loq,
                 check = "CV",
                 by = c("PARAM", "MYEAR", "TISSUE_NAME"),
                 na_matches = "never") %>%
  mutate(MSTAT = factor(MSTAT,  levels = c("IH", "RH", "B"))) %>%
  # Add mean trophic level per station
  group_by(STATION_CODE) %>%
  mutate(TL_mean = mean(TL, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(!is.na(Dist_along_coast))

# dat2 <- dat


```

#### Checking
```{r}

if (FALSE){

  # OCS og «Oktaklorstyren (OCS)
  dat2 %>%
    filter(grepl("OCS", PARAM)) %>%
    xtabs(~PARAM + MYEAR, .)
  dat2 %>%
    filter(grepl("Oktaklor", PARAM)) %>%
    xtabs(~PARAM + MYEAR, .)

  # QCB og «Pentaklorbenzen (QCB)»
  dat2 %>%
    filter(grepl("QCB", PARAM)) %>%
    xtabs(~PARAM + MYEAR, .)

    }
```

### Test add_random_data() function  
```{r}

# Check parameters with ca 50% under LOQ
dat2 %>%
  filter(MYEAR > 2014) %>%
  group_by(PARAM) %>%
  summarise(less_thans = mean(!is.na(FLAG1))) %>%
  filter(less_thans < 0.5) %>%
  arrange(desc(less_thans))

# Just pick 10 randm PFUdA records
test <- dat2 %>%
  filter(PARAM %in% "PFUdA") %>%
  select(MYEAR, STATION_CODE, VALUE_WW, FLAG1, LOQ) %>%
  head(10)

test
# debugonce(add_random_data)
test %>% add_random_data()
test %>% add_random_data()

```


### Use correct basis  
```{r}

pah <- c("ACNLE", "ACNE", "FLE", "PA", "ANT", "FLU", "PYR", "BAA", 
         "CHR", "BBJF", "BKF", "BAP", "DBA3A", "BGHIP", "ICDP", "NAP", 
         "BBJKF", "BJKF", "PAH16", "KPAH", "P_S") 
pfas <- c("PFOS", "PFOSA", "PFBS", "PFDcA", "PFHxA", "PFHxS", 
          "PFHpA", "PFUdA", "PFOA", "PFNA", "PFUdA")
metals <- c("AG", "AS", "CD", "CO", "CR", "CU", "HG", "SN", 
            "NI", "PB", "ZN")

dat2 <- dat2 %>%
  mutate(CONC = case_when(
    PARAM %in% c(pah, pfas, metals) ~ VALUE_DW,
    !PARAM %in% c(pah, pfas, metals) ~ VALUE_WW
  ),
  Basis = case_when(
    PARAM %in% c(pah, pfas, metals) ~ "Dry weight",
    !PARAM %in% c(pah, pfas, metals) ~ "Wet weight"
  )
  )
  
table(dat2$Basis)

```


### Data for plotting maps  
Used in part 8  
```{r}
#
# Get Norway map data
#
test <- maps::map("world", "Norway", plot = FALSE)   # map data for Norway - this is just to get region names
sel <- grepl("Svalbard", test$names) | test$names == "Norway:Jan Mayen"  # select Svalbard + Jan Mayen
# test$names[!sel]
map <- maps::map("world", test$names[!sel], exact = TRUE, plot = FALSE)  # Norway w/o Svalbard + Jan Mayen
mapdata <- data.frame(Longitude = map$x, Latitude = map$y)

#
# Add UTM coordinates (x and y) to map
#
coordinate_exists <- !is.na(mapdata$Longitude)   # sp doesn't like NAs
SP <- sp::SpatialPoints(mapdata[coordinate_exists, c("Longitude", "Latitude")],
                    proj4string=CRS(crs_longlat)
)
SP.UTM <- sp::spTransform(SP, CRS(crs_utm))
# Add transformed coords to data set
mapdata$x[coordinate_exists] <- SP.UTM@coords[,1]
mapdata$y[coordinate_exists] <- SP.UTM@coords[,2]


#
# "Coast" data (coordinates for segments along the coast)
#
coast <- readRDS("Data/102_coast_coordinates.rmd")

#
# Make 'coastsegment_distance'   
#
# Distances for start points of the coast segments
segment_dx <- diff(coast$x)/1000
segment_dy <- diff(coast$y)/1000
coastsegment_distance <- sqrt(segment_dx^2 + segment_dy^2) %>% cumsum()
coastsegment_distance <- c(0, coastsegment_distance)

```

## 3. dat_param - data for one parameter   

```{r}

# All metals  
dat2 %>%
  filter(nchar(PARAM) == 2 & MYEAR >= 2014) %>%
  xtabs(~PARAM + MYEAR, .)

param <- "NI"
# tissue <- "Lever"
tissue <- "Whole soft body"

dat_param <-  dat2 %>%
  filter(PARAM %in% param & TISSUE_NAME %in% tissue) %>% 
  add_random_data() %>%
  mutate(log_CONC = log10(VALUE_WW)) %>%
  select(PARAM, STATION_CODE, TISSUE_NAME, MSTAT, log_CONC, MYEAR, Dist_along_coast, LNMEA, FAT_PERC, TL, TL_mean) # %>%


# Check missing values per year
dat_param %>%
  filter(MYEAR >= 2014) %>%
  split(.$MYEAR) %>%
  purrr::map(~apply(is.na(.), 2, mean))

dat_param %>%
  filter(MYEAR >= 2014) %>%
  xtabs(~STATION_CODE + MYEAR, .)


```

## 4. Test: dist_along_coast, adjust separetely for each station     
- First adjust for length, fat and trophic level, separately for each station  
    + Test for one series, using `dat_param`  
    +  In (b) and (c), variable log_CONC_adj is added, creates `dat_param2`  
- Then (d) analyse the adjusted values by year and distance along coast  
- 

### a. Check data patterns  
```{r}

df_summ <- dat2 %>%
  filter(PARAM %in% param & TISSUE_NAME %in% tissue) %>%
  group_by(STATION_CODE, MYEAR) %>%
  summarise(n = n(), median = median(VALUE_WW), below_loq = mean(!is.na(FLAG1)), loq = mean(LOQ),
            has_LNMEA = mean(!is.na(LNMEA)), has_TL = mean(!is.na(TL))) 

ggplot(df_summ, aes(MYEAR, STATION_CODE)) +
  geom_tile(aes(fill = n))

ggplot(df_summ, aes(MYEAR, STATION_CODE)) +
  geom_tile(aes(fill = below_loq))

ggplot(df_summ, aes(MYEAR, STATION_CODE)) +
  geom_tile(aes(fill = loq))

ggplot(df_summ, aes(MYEAR, STATION_CODE)) +
  geom_tile(aes(fill = has_LNMEA))

ggplot(df_summ, aes(MYEAR, STATION_CODE)) +
  geom_tile(aes(fill = has_TL))
```



### b. Adjust for length and fat (LF), functions    
We do not include trophic level (TL) as there are data only since 2015  
So it will (somehow) be included in the analysese on a per-station basis instead   
  
#### Test `add_adjusted_value_LF`   
Adds the variable log_CONC_adj - creates `dat_param2`   
May also remove some records 
Note that you can select the response variable you want
```{r}

#
# Note: add_adjusted_value_LF() may remove some records
#

dim(dat_param)
dat_param2 <- add_adjusted_value_LF(dat_param, LNMEA_fixed = 500, FAT_PERC_fixed = 40, plot = FALSE)
cat("\n")
dim(dat_param2)

# names(dat_param)
# names(dat_param2)


```


#### Plots of 'dat_param2'  
```{r, fig.height=5, fig.width=7}

ggplot(dat_param2, aes(log_CONC, log_CONC_adj)) +
  geom_point()

dat_param2 %>%
  group_by(MYEAR, STATION_CODE) %>%
  summarise_at(vars(log_CONC, log_CONC_adj), list(mean=mean, min=min, max=max)) %>%
  ggplot(aes(MYEAR, log_CONC_mean)) +
  geom_pointrange(aes(ymin = log_CONC_min, ymax = log_CONC_max), size = rel(0.2)) +
  geom_pointrange(aes(x = MYEAR + 0.35, y = log_CONC_adj_mean, 
                      ymin = log_CONC_adj_min, ymax = log_CONC_adj_max),
                  color = "red", size = rel(0.2)) +
  facet_wrap(vars(STATION_CODE)) +
  labs(title = "Log concentrations (mean, min and max)", subtitle = "Black = raw concentration, red = adjusted")

ggplot(dat_param2, aes(log_CONC_adj - log_CONC, LNMEA)) +
  geom_point()

ggplot(dat_param2, aes(log_CONC_adj - log_CONC, FAT_PERC)) +
  geom_point()

```


#### Test using random values
```{r}

dat_param2_random <- dat2 %>%
  filter(PARAM %in% "PFUdA" & TISSUE_NAME %in% "Lever") %>% 
  add_random_data() %>%
  mutate(log_CONC = log10(VALUE_WW),
         log_CONC_r = log10(VALUE_WW_r)) %>%
  select(STATION_CODE, TISSUE_NAME, MSTAT, log_CONC, log_CONC_r, MYEAR, Dist_along_coast, LNMEA, FAT_PERC, TL, TL_mean) %>%
  add_adjusted_value_LF(LNMEA_fixed = 500, FAT_PERC_fixed = 40, plot = FALSE, response_variable = "log_CONC_r")

names(dat_param2_random)

```

### c. Adjust for fat only    
For blue mussel, where we lack length for a lot of years  

#### Function `add_adjusted_value_F`   
- to use for data containing one parameter/tissue       
```{r, fig.height=3, fig.width=9}

#
# Note: add_adjusted_value_LF() may remove some records
#
dim(dat_param)
dat_param2 <- add_adjusted_value_F(dat_param, plot = FALSE)
cat("\n")
dim(dat_param2)

# names(dat_param)
# names(dat_param2)


```



### d. Linear analysis by year and dist. along coast   
Use gls with AR1 model  

#### Test
```{r}
dat_param2 %>%
  filter(is.na(Dist_along_coast))
# PSeudorepl
mod0 <- gls(log_CONC_adj ~ MYEAR + Dist_along_coast, data = dat_param2)
acf(residuals(mod0), type = "partial")

# Autocorrelation structure only
mod10 <- gls(log_CONC_adj ~ 1, data = dat_param2,
            correlation = corAR1(form = ~1 | STATION_CODE))
acf(residuals(mod10), type = "partial")

# Year
mod1a <- gls(log_CONC_adj ~ MYEAR, data = dat_param2,
            correlation = corAR1(form = ~1 | STATION_CODE))
# Dist_along_coast
mod1b <- gls(log_CONC_adj ~ Dist_along_coast, data = dat_param2,
            correlation = corAR1(form = ~1 | STATION_CODE))
# Year + Dist_along_coast
mod1c <- gls(log_CONC_adj ~ MYEAR + Dist_along_coast, data = dat_param2,
            correlation = corAR1(form = ~1 | STATION_CODE))
# Year - Dist_along_coast - interaction
mod1d <- gls(log_CONC_adj ~ MYEAR*Dist_along_coast, data = dat_param2,
            correlation = corAR1(form = ~1 | STATION_CODE))

aic <- AIC(mod0, mod10, mod1a, mod1b, mod1c, mod1d)
aic$dAIC <- aic$AIC - min(aic$AIC)
aic

# AIC says that "models are not all fitted to the same number of observations"
# BUT they are! (see below)
cat("\n")
list(mod0, mod10, mod1a, mod1b, mod1c, mod1d) %>% map_int(~summary(.)$dims$N)

# summary(mod1d) %>% str()
summary(mod1a)$tTable

# summary(mod1d)$tTable
# summary(mod1c)$tTable
# summary(mod1c)$tTable
# summary(mod1c)$tTable[2:3,] %>% matrix(nrow = 1) %>% data.frame()


```

#### Test function 'run_gls'    
```{r}

# Used in section 6
model_string <- data.frame(
  modelnumber = 1:5,
  model = c("~", 
            "~ MYEAR",
            "~ Dist_along_coast",
            "~ MYEAR + Dist_along_coast",
            "~ MYEAR*Dist_along_coast")
)

# debugonce(run_gls)
# run_gls(dat_param2)

list(dat_param2,
     dat_param2 %>% filter(MSTAT != "IH")) %>% 
  map_dfr(run_gls)


```

#### Test using random values  
```{r}
run_gls(dat_param2_random,  response_variable = "log_CONC_r_adj") 
run_gls(dat_param2_random,  response_variable = "log_CONC") 

```


### e. Test function for one replicate    
Function `analysis_one_par_one_repl` 
```{r}

# Testing 
analysis_one_par_one_repl("CB118", "Lever", dat2)  

if (FALSE){

  # analysis_one_par_one_repl
  debugonce(analysis_one_par_one_repl)
  analysis_one_par_one_repl("NI", "Whole soft body", dat2)
  analysis_one_par_one_repl("PFUdA", "Lever", dat2)
  analysis_one_par_one_repl("CD", "Whole soft body", dat2)
  debugonce(analysis_one_par_one_repl)
  debugonce(add_adjusted_value_LF)
  analysis_one_par_one_repl("HG", "Muskel", dat2)

  }

# 1:5 %>% set_names()
```

### f. N replicates  

#### Test
```{r}


1:3 %>% 
  set_names() %>% 
  map_dfr(
  ~analysis_one_par_one_repl(param = "PFUdA", 
                             tissue = "Lever", 
                             data = dat2),
  .id = "Repl"
)


```

#### Test function for n replicates    
- `analysis_one_par` 
- Replicates needed since 'add_random_data' will give different results each time  
```{r, warning=FALSE, message = FALSE, results='hold'}

analysis_one_par("NI", "Lever", dat2, nrepl = 2)

if (FALSE){
  analysis_one_par("PFUdA", "Lever", dat2, nrepl = 5)
}


```

## 5a. Linear model - non-impacted stations - all parameters + tissues


### Plot number of data   
Naturally higher for cod than for blue mussel
```{r}

dat2 %>%
  count(PARAM, TISSUE_NAME) %>%
  ggplot(aes(n)) + 
  geom_histogram(binwidth = 200) +
  facet_wrap(vars(TISSUE_NAME)) +
  labs(title = "Number of parameters (y) with a given number of samples (x)")

dat2 %>%
  count(PARAM, TISSUE_NAME) %>% 
  ggplot(aes(n)) + 
  geom_histogram(binwidth = 25) +
  facet_wrap(vars(TISSUE_NAME)) +
  coord_cartesian(xlim = c(0,500)) +
  labs(title = "Number of parameters (y) with a given number of samples (x)",
       subtitle = "Only parameters with <500 samples shown")

```

### Plot number of stations 
```{r}
# Number of parameters/stations 
df_acceptable_stations <- dat2 %>%
  group_by(PARAM, TISSUE_NAME) %>%
  mutate(sample_size = n()) %>%
  count(PARAM, TISSUE_NAME, STATION_CODE, MSTAT, Lat, MYEAR, sample_size) %>%
  filter(n >= 3) %>%  # min. number of samples per parameter/station/year 
  group_by(PARAM, TISSUE_NAME, STATION_CODE, MSTAT, Lat, sample_size) %>%
  summarise(n_years = n(), .groups = "drop") %>%
  filter(n_years >= 3)      # min. number of years per parameter/station
cat("Acceptable PARAM, TISSUE_NAME, STATION_CODE combinations: ", 
    nrow(df_acceptable_stations), "\n")

# Plot
ggplot(df_acceptable_stations, aes(Lat, fill = MSTAT)) +
  geom_histogram(binwidth = 1) +
  facet_wrap(vars(TISSUE_NAME)) +
  labs(title = "Number of acceptable parameters*stations (y) by latitude (x)")


# One line per parameter/tissue/region/impact, n = number of stations  
df_param <- df_acceptable_stations %>%
  mutate(Area = case_when(
    Lat > 65 ~ "North",
    Lat > 63 ~ "Mid",
    TRUE ~ "South"
  ),
  Impacted = (MSTAT == "IH")
  ) %>% 
  arrange(PARAM, TISSUE_NAME, Area) %>%
  count(PARAM, TISSUE_NAME, Area, Impacted, sample_size)

# One line per parameter/tissue - one column per region (all stations)
df_param_all <- df_param %>%
  group_by(PARAM, TISSUE_NAME, Area, sample_size) %>% 
  summarise(n = sum(n), .groups = "drop") %>%
  tidyr::pivot_wider(names_from = "Area", values_from = "n") 

# One line per parameter/tissue - one column per region (unimpacted stations)
df_param_notimpacted <- df_param %>%
  filter(!Impacted) %>%
  tidyr::pivot_wider(names_from = "Area", values_from = "n") %>%
  select(-Impacted)

# One line per tissue/coverage - number gives number of parameters
df1 <- df_param_all %>%
  mutate(Spatial_coverage = case_when(
    North >= 2 ~ "OK",
    TRUE ~ "Not OK")) %>%
  count(TISSUE_NAME, Spatial_coverage) %>% # View()
  rename(All = n)

# One line per tissue/coverage - number gives number of parameters (unimpacted stations)
df2 <- df_param_notimpacted %>%
  mutate(Spatial_coverage = case_when(
    North >= 2 ~ "OK",
    TRUE ~ "Not OK")) %>% # View()
  count(TISSUE_NAME, Spatial_coverage) %>%
  rename(Notimpacted = n) 

# One line per tissue/coverage - number gives number of parameters
check <- left_join(df1, df2, by = c("TISSUE_NAME", "Spatial_coverage"),
          na_matches = "never") #"%>%
  #select(TISSUE_NAME, Spatial_coverage)
# xtabs(~)

kable(check, caption = "Number of parameters")

```

### Select time series - 'series_param_tissue'    
Based on 'df_param_notimpacted'
NOTE: We do NOT filter so we keep only series with => 2 sttions in Norther Norway  
```{r}

series_param_tissue <- dat2 %>%
  distinct(PARAM, TISSUE_NAME) %>%  # View("1")
  # Only difference from the next: using 'df_param_notimpacted' here:
  left_join(df_param_notimpacted, 
            by = c("PARAM", "TISSUE_NAME"),
            na_matches = "never") %>% # filter(PARAM == "PFAS") %>% View("2")
  # filter(North >= 2) %>%    # At least 2 not-impacted time series in Northern Norway
  as.data.frame()

# head(dat_param_tissue)  
cat("Number of time series:", nrow(series_param_tissue), "\n")  

```

Safe version of analysis_one_par  
```{r}
analysis_one_par_s <- safely(analysis_one_par)
```


### Pick data from non-impacted stations (dat2_notimpacted)  
```{r}

dat2_notimpacted <- dat2 %>%
  # Only difference from the next: using 'df_param_notimpacted' here:
  filter(!MSTAT %in% "IH") %>% 
  as.data.frame()

# Test
if (FALSE){
  
  analysis_one_par_s("ZN", "Lever", dat2_notimpacted, nrepl = 3)
  analysis_one_par_s("CB_S7", "Lever", dat2_notimpacted, nrepl = 3)
  analysis_one_par_S("PFUdA", "Lever", dat2_notimpacted, nrepl = 3)
  
  # Test 2
  result_list <- 12:13 %>%
    # result_list <- seq(1,10) %>%
    purrr::map(
      ~analysis_one_par_s(series_param_tissue$PARAM[.], 
                          series_param_tissue$TISSUE_NAME[.], 
                          dat2_notimpacted,    # NOTE
                          nrepl = 3)
    ) %>%
    purrr::transpose()
  
  ok <- result_list[[2]] %>% map_lgl(is.null)
  sum(ok)
  
  result <- result_list[[1]][ok] %>% bind_rows()

  
}

```

### Run analysis for all non-impacted stations   
Is only run if 'run_analysis' = TRUE, otherwise we use saved data (next chunk)
```{r, warning=FALSE, message=FALSE}

# run_analysis <- TRUE
run_analysis <- FALSE

if (run_analysis){
  
  # For taking the time 
  t0 <- Sys.time()
  
  result_list <- 1:nrow(series_param_tissue) %>%
    # result_list <- seq(1,10) %>%
    purrr::map(
      ~analysis_one_par_s(series_param_tissue$PARAM[.], 
                          series_param_tissue$TISSUE_NAME[.], 
                          dat2_notimpacted,    # NOTE
                          nrepl = 3)
    ) %>%
    purrr::transpose()
  
  # For takng the time 
  t1 <- Sys.time()
  t1-t0     # 6.75 minutes
  
} else {
  
  # If run_analysis = FALSE, we just use the saved data
  result_list <- readRDS("Data/120_result_list_notimpacted.rds")

}

```

### Save   
We only run the "saveRDS" line if we have run a new analysis (run_analysis = TRUE)  
Otherwise we just read the saved data  
```{r}

if (run_analysis){
  saveRDS(result_list, "Data/121_result_list_notimpacted.rds")
} else {
  result_list <- readRDS("Data/121_result_list_notimpacted.rds")
}

length(result_list[["result"]])
length(result_list[["error"]])
result_list[["result"]][[1]]

i <- which(
  with(
    series_param_tissue,
    PARAM == "MCCP" & TISSUE_NAME == "Whole soft body"))
result_list[["result"]][[i]]

```


### Linear_results - store result as 'linear_results'  
```{r}

ok <- result_list[[2]] %>% map_lgl(is.null)
cat("Number of regressions that worked (numbers / fraction): \n")
sum(ok)
mean(ok)

# series_param_tissue$Result_nonimpact <- ok

linear_results <- result_list[[1]][ok] %>% 
  bind_rows() %>% 
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code"),
            na_matches = "never") %>%
  select(Substance.Group, everything()) %>%
  arrange(Substance.Group)

```

## 5b. Linear model - all stations except Oslo + Sørfjorden - all parameters + tissues

### Pick data     
```{r}
series_param_tissue[12:13,]

dat2_lessimpacted <- dat2 %>%
  # Only difference from the next: using 'df_param_notimpacted' here:
  filter(!STATION_CODE %in% c("30B","53B")) %>% 
  as.data.frame()

# Test
if (FALSE){
  
  analysis_one_par_s("ZN", "Lever", dat2_lessimpacted, nrepl = 3)
  analysis_one_par_s("CB_S7", "Lever", dat2_lessimpacted, nrepl = 3)
  analysis_one_par_S("PFUdA", "Lever", dat2_lessimpacted, nrepl = 3)
  
  # Test 2
  result_list <- 12:13 %>%
    # result_list <- seq(1,10) %>%
    purrr::map(
      ~analysis_one_par_s(series_param_tissue$PARAM[.], 
                          series_param_tissue$TISSUE_NAME[.], 
                          dat2_lessimpacted,    # NOTE
                          nrepl = 3)
    ) %>%
    purrr::transpose()
  
  ok <- result_list[[2]] %>% map_lgl(is.null)
  sum(ok)
  
  result <- result_list[[1]][ok] %>% bind_rows()

  
}

```

### Run analysis for all "less-impacted" stations   
Is only run if 'run_analysis' = TRUE, otherwise we use saved data (next chunk)
```{r, warning=FALSE, message=FALSE}

# run_analysis <- TRUE
run_analysis <- FALSE

if (run_analysis){
  
  # For taking the time 
  t0 <- Sys.time()
  
  result_list2 <- 1:nrow(series_param_tissue) %>%
    # result_list <- seq(1,10) %>%
    purrr::map(
      ~analysis_one_par_s(series_param_tissue$PARAM[.], 
                          series_param_tissue$TISSUE_NAME[.], 
                          dat2_lessimpacted,    # NOTE
                          nrepl = 3)
    ) %>%
    purrr::transpose()
  
  # For takng the time 
  t1 <- Sys.time()
  t1-t0     # 6.75 minutes
  
} else {
  
  # If run_analysis = FALSE, we just use the saved data
  result_list2 <- readRDS("Data/120_result_list_notimpacted.rds")

}

```

### Save   
We only run the "saveRDS" line if we have run a new analysis (run_analysis = TRUE)  
Otherwise we just read the saved data  
```{r}

if (run_analysis){
  saveRDS(result_list2, "Data/121_result_list_lessimpacted.rds")
} else {
  result_list2 <- readRDS("Data/121_result_list_lessimpacted.rds")
}

length(result_list2[["result"]])
length(result_list2[["error"]])
# result_list2[["result"]][[1]]

```


### Linear_results - store result as 'linear_results'  
```{r}

ok <- result_list2[[2]] %>% map_lgl(is.null)
cat("Number of regressions that worked (numbers / fraction): \n")
sum(ok)
mean(ok)

# series_param_tissue$Result_nonimpact <- ok

linear_results2 <- result_list2[[1]][ok] %>% 
  bind_rows() %>% 
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code"),
            na_matches = "never") %>%
  select(Substance.Group, everything()) %>%
  arrange(Substance.Group)

```


## 6. Check results  

### Best AIC   
See function 'run_gls' (section 4, 'Linear analysis by year and dist.') for models  

```{r, results='hold'}

cat("Non-impacted stations: \n")
linear_results %>%
  left_join(model_string, by = c("Best_model" = "modelnumber")) %>%
  xtabs(~model + TISSUE_NAME, .)

cat("\n")
cat("Less-impacted stations (all stations except Oslo and Sørfjorden): \n")
linear_results2 %>%
  left_join(model_string, by = c("Best_model" = "modelnumber")) %>%
  xtabs(~model + TISSUE_NAME, .)

```


### Table of estimates     
As a beautiful (?) kable table  
```{r, warning = FALSE}


linear_results %>%
  filter(TISSUE_NAME %in% "Lever") %>%
  group_by(Substance.Group, PARAM, TISSUE_NAME) %>%
  summarise_all(list(min = min, mean = mean, median = median)) %>%
  ungroup() %>%
  mutate(Position_est_mean = (1000*Position_est_mean) %>% round(3),
         Position_se_mean = (1000*Position_se_mean) %>% round(3),
         P = format_p(Position_p_median),
         Parameter = cell_spec(
           PARAM, "html", 
           color = ifelse(Position_p_median < 0.05, "red", "black")),
         Distance_along_coast = cell_spec(
           Position_est_mean, "html", 
           color = ifelse(Position_p_median < 0.05, "red", "black")),
         SE = cell_spec(
           Position_se_mean, "html",
           color = ifelse(Position_p_median < 0.05, "red", "black")),
         `P-value` = cell_spec(
           P, "html", 
           color = ifelse(Position_p_median < 0.05, "red", "black")),
  ) %>%
  select(Parameter, Distance_along_coast, SE, `P-value`) %>%
  knitr::kable(format = "html", escape = FALSE) %>%
  kableExtra::kable_styling(bootstrap_options = "condensed")

# writeLines(table, "clipboard")
# table



```

## 7. Additive GAMM (additive distance and time effects)      

We use a bit different approach than in part 4-5:     
- run_gamm() returns a list of two data frames (run_gls returned just a one.line data frame)  
- thus, to avoid too many "list layers" in the final result, we skip the analysis_one_par()
  function (see "function for n replicates, above)  
- the final run runs through a data frame (listno_replicate) with e.g. 3 rows per 
  parameter/tissue (for 3 replicates of below-LOQ numbers)   
  
#### Functions for GAMM    


```{r, fig.width = 8, fig.height=3.5}

# Test function 3
z <- run_gamm(dat_param2, repl = 1)
str(z, 1)


```





### Test 1 - one replicate, one series        
Test 3 different outputs:  
1) ttable_and_fit  (default)
2) plotvalues   
3) model_and_data  
```{r}

# interaction = FALSE is used in this part (section 7-9)
# interaction = TRUE is used from section 10 onwards

#
# 1. Testing one series, using default options
#
x1 <- gamm_one_par_one_repl("BDE47", "Lever", dat2_notimpacted)
# x1 <- gamm_one_par_one_repl("HG", "Muskel", dat2_notimpacted)

ggplot(x1$plotvalues, aes(Dist_along_coast, visregFit)) +
  geom_ribbon(aes(ymin = visregLwr, ymax = visregUpr), fill = "grey70") +
  geom_line()


#
# 2. Test using return = "plotvalues" (used in script 122)
#
x1 <- gamm_one_par_one_repl("NI", "Lever", dat2, return = "plotvalues")
str(x1, 1)
str(x1$fit, 1)

ggplot(x1$fit, aes(Dist_along_coast, visregFit)) +
  geom_ribbon(aes(ymin = visregLwr, ymax = visregUpr), fill = "grey70") +
  geom_line() +
  geom_point(data = x1$res, aes(y = visregRes), color = "black", alpha = 0.3)

#
# 3. Test using return = "model_an_data" (used in script 122)
#
x1 <- gamm_one_par_one_repl("NI", "Lever", dat2_notimpacted, return = "model_and_data")
# str(x1, 1)
summary(x1$mod$gam)
par(mfrow = c(1,2), mar = c(4,5,2,1))
visreg(x1$mod$gam)

x1 <- gamm_one_par_one_repl("NI", "Lever", dat2_notimpacted, return = "model_and_data")
x1 <- gamm_one_par_one_repl("BDE47", "Lever", dat2_notimpacted, return = "model_and_data")
# str(x1, 1)
summary(x1$mod$gam)
par(mfrow = c(1,2), mar = c(4,5,2,1))
visreg(x1$mod$gam)


#
# Adding another series, show both
#
# debugonce(gamm_one_par_one_repl)
# debugonce(run_gamm)
# debugonce(run_gamm_model)
# debugonce(run_gamm_extract_results)
# x2 <- gamm_one_par_one_repl("Dieldrin", "Whole soft body", dat2)
```

### Test 2 - one replicate, two series         
```{r}

x2 <- gamm_one_par_one_repl("PFUdA", "Lever", dat2)

# Show t values
list(x1, x2) %>% map_df(~.$ttable)

# Show plot
list(x1, x2) %>% 
  map_df(~.$plotvalues) %>%
  ggplot(aes(Dist_along_coast, visregFit)) +
    geom_ribbon(aes(ymin = visregLwr, ymax = visregUpr, fill = PARAM), alpha = 0.5) +
    geom_line(aes(color = PARAM))

  

```


### Run for all parameters and replicates  
  
#### Test 1      
Two first parameters only    
```{r}

if (FALSE){ 
  
  # 1:nrow(series_param_tissue) %>%
  
  nrow <- 2  # number of parameters/tissues
  nrep <- 2  # number of replicates
  
  # Data frame with two columns, col. 1 for parameter/tissue, col. 2 for replicate  
  listno_replicate <- data.frame(
    listno = rep(1:nrow, each = nrep),
    replicate = rep(1:nrep, nrow)
  )
  nrow(listno_replicate)  # 4
  
  series_param_tissue[1:nrow,]
  
  # GAM analyses  
  x <- 1:nrow(listno_replicate) %>%
    map(
      ~gamm_one_par_one_repl(
        series_param_tissue$PARAM[listno_replicate$listno[.]], 
        series_param_tissue$TISSUE_NAME[listno_replicate$listno[.]],
        repl = listno_replicate$listno[.],
        data = dat2)
    )
  
  str(x, 1)            # list of 4 lists
  str(x[[1]], 1)       # list of 2, ttable and plotvalues
  
}


```

#### Test 2        
Run for a specific parameter/tissue      
```{r}

if (FALSE){ 
  
  param <- "HG"
  tissue <- "Muskel"
  param <- "PFOS"
  tissue <- "Lever"
  i <- with(series_param_tissue, which(PARAM == param & TISSUE_NAME == tissue))
  series_param_tissue[i,]
  i
  
  # 1:nrow(series_param_tissue) %>%
  
  # nrow <- 2  # number of parameters/tissues
  nrep <- 3  # number of replicates
  
  # Data frame with two columns, col. 1 for parameter/tissue, col. 2 for replicate  
  listno_replicate <- data.frame(
    listno = rep(i, each = nrep),
    replicate = rep(1:nrep, length(i))
  )
  nrow(listno_replicate)  # 4
  listno_replicate

  # GAM analyses, all stations  
  x <- 1:nrow(listno_replicate) %>%
    map(
      ~gamm_one_par_one_repl(
        series_param_tissue$PARAM[listno_replicate$listno[.]], 
        series_param_tissue$TISSUE_NAME[listno_replicate$listno[.]],
        repl = listno_replicate$listno[.],
        data = dat2)
    )
  
  str(x, 1)            # list of 3 lists
  str(x[[1]], 1)       # list of 2, ttable and plotvalues
  x %>% map_dfr(~.$ttable)
  
  # GAM analyses, non-impacted stations  
  x <- 1:nrow(listno_replicate) %>%
    map(
      ~gamm_one_par_one_repl(
        series_param_tissue$PARAM[listno_replicate$listno[.]], 
        series_param_tissue$TISSUE_NAME[listno_replicate$listno[.]],
        repl = listno_replicate$listno[.],
        data = dat2_notimpacted)       # this is the only change  
    )
  
  str(x, 1)            # list of 3 lists
  str(x[[1]], 1)       # list of 2, ttable and plotvalues
  x %>% map_dfr(~.$ttable)

  }


```

### a. All stations - All parameters/tissues  
Is only run if 'run_analysis' = TRUE, otherwise we use saved data   
```{r}

# Safe version
gamm_one_par_one_repl_s <- safely(gamm_one_par_one_repl)

# Set up
nrow <- nrow(series_param_tissue)  # number of parameters/tissues
nrep <- 3                          # number of replicates

# Set up data frame with two columns, col. 1 for parameter/tissue, col. 2 for replicate  
listno_replicate <- data.frame(
  listno = rep(1:nrow, each = nrep),
  replicate = rep(1:nrep, nrow)
)
cat("Length of listno_replicate: \n")
nrow(listno_replicate)  # 1014

#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o
#
# Set this to TRUE to recalculate all annalyses
#
# If FALSE, saved results are used  
#
#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o

run_analysis <- FALSE  
# run_analysis <- TRUE  

if (run_analysis) {
  
  # For taking the time 
  t0 <- Sys.time()
  
  # GAM analyses  
  gamm_list0 <- 1:nrow(listno_replicate) %>%
    map(
      ~gamm_one_par_one_repl_s(
        series_param_tissue$PARAM[listno_replicate$listno[.]], 
        series_param_tissue$TISSUE_NAME[listno_replicate$listno[.]],
        repl = listno_replicate$replicate[.],
        data = dat2)
    ) %>%
    purrr::transpose()
  
  # For takng the time 
  t1 <- Sys.time()
  t1-t0     # 16 minutes
  
}
  
```

### Save  
REMEMBER to comment out 'run_analysis <- TRUE' in the previous chunk after saving  
Only done once, when we have run the entire analysis  
```{r}

if (run_analysis) {
  saveRDS(gamm_list0, "Data/121_gamm_list0.rds")
} else {
  gamm_list0 <- readRDS("Data/121_gamm_list0.rds")
}

cat("\n gamm_list0: \n")
str(gamm_list0, 1)              # list of 2 lists, "result" and "error"

cat("\n gamm_list0$result: \n")
length(gamm_list0$result)       # list of 555

cat("\n gamm_list0$result number 1: \n")
str(gamm_list0$result[[1]], 1)  # list of 2 data frames, ttable (1 row) and plotvalues (101 rows)

cat("\n gamm_list0$result number 1's t-table: \n")
str(gamm_list0$result[[1]]$ttable)  



```

#### b. Non-impacted stations - all parameters/tissues  
Is only run if 'run_analysis' = TRUE, otherwise we use saved data   
```{r}

# Safe version
gamm_one_par_one_repl_s <- safely(gamm_one_par_one_repl)

# Set up
nrow <- nrow(series_param_tissue)  # number of parameters/tissues
nrep <- 3                          # number of replicates

# Set up data frame with two columns, col. 1 for parameter/tissue, col. 2 for replicate  
listno_replicate <- data.frame(
  listno = rep(1:nrow, each = nrep),
  replicate = rep(1:nrep, nrow)
)
cat("Length of listno_replicate: \n")
nrow(listno_replicate)  # 1014

#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o
#
# Set this to TRUE to recalculate all annalyses
#
# If FALSE, saved results are used  
#
#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o

run_analysis <- FALSE  
# run_analysis <- TRUE

if (run_analysis) {
  
  # For taking the time 
  t0 <- Sys.time()
  
  # GAM analyses  
  gamm_list1 <- 1:nrow(listno_replicate) %>%
    map(
      ~gamm_one_par_one_repl_s(
        series_param_tissue$PARAM[listno_replicate$listno[.]], 
        series_param_tissue$TISSUE_NAME[listno_replicate$listno[.]],
        repl = listno_replicate$replicate[.],
        data = dat2_notimpacted)
    ) %>%
    purrr::transpose()
  
  # For takng the time 
  t1 <- Sys.time()
  t1-t0     # 16 minutes
  
  
} 


```

### Save  
Only done once, when we have run the entire analysis    
REMEMBER to comment out 'run_analysis <- TRUE' in the previous chuck afterwards  
```{r}

if (run_analysis){
  saveRDS(gamm_list1, "Data/121_gamm_list1.rds")
} else {
  gamm_list1 <- readRDS("Data/121_gamm_list1.rds")
}

cat("\n gamm_list0: \n")
str(gamm_list0, 1)              # list of 2 lists, "result" and "error"

cat("\n gamm_list0$result: \n")
length(gamm_list0$result)       # list of 543

cat("\n gamm_list0$result number 1: \n")
str(gamm_list0$result[[1]], 1)  # list of 2 data frames, ttable (1 row) and plotvalues (101 rows)

cat("\n gamm_list0$result number 1's t-table: \n")
str(gamm_list0$result[[1]]$ttable)  

if (FALSE){
  
  # Check a specific parameter/tissue
  param <- "HG"
  i <- with(series_param_tissue, which(PARAM == "HG" & TISSUE_NAME == "Muskel"))
  cat("i =", i, "\n")
  # series_param_tissue[i,]
  j <- with(listno_replicate, which(listno == i))
  cat("j =", j, "\n")
  # series_param_tissue[i,]
  gamm_list1$error[j]  
  # A term has fewer unique covariate combinations than specified maximum degrees of freedom  
  
  # GAM analyses, non-impacted stations  
  # GAM analyses  
  gamm_list1_EXTRA <- j %>%
    map(
      ~gamm_one_par_one_repl_s(
        series_param_tissue$PARAM[listno_replicate$listno[.]], 
        series_param_tissue$TISSUE_NAME[listno_replicate$listno[.]],
        repl = listno_replicate$replicate[.],
        data = dat2_notimpacted)
    ) %>%
    purrr::transpose()
  
  str(x, 1)            # list of 3 lists
  str(x[[1]], 1)       # list of 2, ttable and plotvalues
  x %>% map_dfr(~.$ttable)

    
  
  
}

```


#### c. 'Less-impacted' stations - all parameters/tissues    
'Less-impacted' = all stations except 30B + 53B  
Is only run if 'run_analysis' = TRUE, otherwise we use saved data   
```{r}

# Safe version
gamm_one_par_one_repl_s <- safely(gamm_one_par_one_repl)

# Set up
nrow <- nrow(series_param_tissue)  # number of parameters/tissues
nrep <- 3                          # number of replicates

# Set up data frame with two columns, col. 1 for parameter/tissue, col. 2 for replicate  
listno_replicate <- data.frame(
  listno = rep(1:nrow, each = nrep),
  replicate = rep(1:nrep, nrow)
)
cat("Length of listno_replicate: \n")
nrow(listno_replicate)  # 1014

#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o
#
# Set this to TRUE to recalculate all annalyses
#
# If FALSE, saved results are used  
#
#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o

run_analysis <- FALSE  
# run_analysis <- TRUE

if (run_analysis) {
  
  # For taking the time 
  t0 <- Sys.time()
  
  # GAM analyses  
  gamm_list2 <- 1:nrow(listno_replicate) %>%
    map(
      ~gamm_one_par_one_repl_s(
        series_param_tissue$PARAM[listno_replicate$listno[.]], 
        series_param_tissue$TISSUE_NAME[listno_replicate$listno[.]],
        repl = listno_replicate$replicate[.],
        data = dat2_lessimpacted)
    ) %>%
    purrr::transpose()
  
  # For takng the time 
  t1 <- Sys.time()
  t1-t0     # 16 minutes
  
  
} 


```

### Save  
Only done once, when we have run the entire analysis    
REMEMBER to comment out 'run_analysis <- TRUE' in the previous c
```{r}

if (run_analysis){
  saveRDS(gamm_list2, "Data/121_gamm_list2.rds")
} else {
  gamm_list2 <- readRDS("Data/121_gamm_list2.rds")
}

cat("\n gamm_list2: \n")
str(gamm_list2, 1)              # list of 2 lists, "result" and "error"

cat("\n gamm_list2$result: \n")
length(gamm_list2$result)       # list of 555
str(gamm_list2$result[[1]], 1)  # list of 2 data frames, ttable (1 row) and plotvalues (101 rows)

if (FALSE){
  # Check one particular parameter/tissue
  # First, combine all the one-line t-tables   
  df <- gamm_list0$result %>% map_dfr(~.$ttable)
  # Get the index we want
  i <- with(df, which(PARAM == "HG" & TISSUE_NAME == "Muskel"))
  i
  df[i,]
  # Check if its OK
  # All 
  result_ok <- gamm_list0[["error"]] %>% map_lgl(is.null)
  result_ok[i]
  
}


```


## 8a. All stations - additive GAMM  

### Get analyses that didn't fail  
```{r, results='hold'}

gamm_list <- gamm_list0

cat("Number of regressions that worked (numbers / percentage): \n")
ok <- gamm_list[["error"]] %>% map_lgl(is.null)
cat(sum(ok), "/", 100*mean(ok))  # 0.91

# Save "ok" in data frame used to run analysis
# listno_replicate$Result_ok <- ok

if (FALSE){
  i <- grep("Heptaklorepoksid", series_param_tissue$PARAM)
  j <- which(listno_replicate$listno %in% i)
  ok[j]
}
```


## 8b. Non-impacted stations - additive GAMM  

### Get analyses that didn't fail  
```{r, results='hold'}

gamm_list <- gamm_list1

cat("Number of regressions that worked (numbers / percentage): \n")
ok <- gamm_list1[["error"]] %>% map_lgl(is.null)
cat(sum(ok), "/", 100*mean(ok))  # 0.91

# Save "ok" in data frame used to run analysis
# listno_replicate$Result_ok <- ok

if (FALSE){
  i <- grep("Heptaklorepoksid", series_param_tissue$PARAM)
  j <- which(listno_replicate$listno %in% i)
  ok[j]
}
```

### Extract t-values and plot values (fitted lines)  
- t-values: ttable_gamm  
- Also take the median fitted lines (across replicates): plotvalues_gamm_med     
- Also add 'Substance.Group' for both    
```{r, warning=FALSE, results='hide', message=FALSE}

# Extract the one-line t-tables and combine
ttable_gamm <- gamm_list[["result"]][ok] %>% 
  map_df(~.[["ttable"]]) %>%
  # Add substance group
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code"))

# All numbers are character, set to numeric
vars <- c("Repl", 
          "Year_edf", "Position_esdf", "Year_F", 
          "Position_F", "Year_p", "Position_p")
for (var in vars)
  ttable_gamm[[var]] <- as.numeric(ttable_gamm[[var]])

# Extract the line fits for the "Positopn" effects  
plotvalues_gamm <- gamm_list[["result"]][ok] %>% 
  map_df(~.[["plotvalues"]])

# Median fitted lines (across replicates)
plotvalues_gamm_med <- plotvalues_gamm %>%
  group_by(PARAM, TISSUE_NAME, Dist_along_coast) %>%
    summarise_at(
    vars(visregFit, visregLwr, visregUpr),
    median) %>%
  # Add substance group
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code"))

# Check 'plotvalues_gamm' and 'plotvalues_gamm_med' for 
#   a parameter with many <LOQ values (BAP)
if (FALSE){
plotvalues_gamm %>%
  filter(PARAM == "BAP") %>%
  # We cheat a bit to recreate how Repl should actually be (because of code error; now fixed):
  mutate(Repl = rep(1:3, each = 101)) %>%   # xtabs(~TISSUE_NAME + Repl, .) 
  ggplot(aes(Dist_along_coast, visregFit)) + 
  geom_path(aes(color = factor(Repl)), size = 2) +
  geom_path(
    data = plotvalues_gamm_med %>% filter(PARAM == "BAP"),
    aes(Dist_along_coast, visregFit),
    linetype = 2
  )
}

ttable_gamm %>%
  mutate(Result = case_when(
    Position_p > 0.05 ~ "No significant effect of distance along coast",
    Position_esdf <= 1 ~ "Linear effect of distance along coast",
    Position_esdf > 1 ~ "Non-linear effect of distance along coast")
    ) %>%
  xtabs(~Result, .)

```

### Check p-values and the fit's degrees of freedom    
- fit's degrees of freedom > 1 (second graph) means non-linear fit   
- Position_p 
```{r, results='hold'}



ttable_gamm %>%
  ggplot(aes(Position_p)) + geom_histogram()
ttable_gamm %>%
  ggplot(aes(Position_p, Position_esdf)) + geom_point()

ttable_gamm %>%
  xtabs(~(Position_p < 0.05) + (Position_esdf > 1), .)

ttable_gamm %>%
  xtabs(~ addNA(Substance.Group) + (Position_p < 0.05) + TISSUE_NAME, .)

# for checking
if (FALSE){
  ttable_gamm %>%
    filter(is.na(Substance.Group)) %>%
    xtabs(~PARAM, .) %>%
    names() %>%
    paste(collapse = ";")
}


```

### Plot fits for one group       
Both horizontally and vertically
```{r, fig.width = 8, fig.height = 6} 

group <- "Organobromines"

gg <- plotvalues_gamm_med %>%
  # Add 'Position_p' (p-values) to data
  left_join(ttable_gamm %>% select(PARAM, TISSUE_NAME, Position_p), 
            by = c("PARAM", "TISSUE_NAME")) %>%
  mutate(Significant = ifelse(Position_p < 0.05, "Significant", "Not significant")) %>%
  filter(Substance.Group %in% group &
           TISSUE_NAME %in% "Lever"
           ) %>% 
  ggplot(aes(Dist_along_coast, visregFit, color = PARAM, linetype = Significant)) + 
  geom_line() + 
  scale_linetype_manual(values = c(2,1))

gg

gg +
  coord_flip()

```

### Plot results with map   
Example: Organobromines   
- Pick only the most common ones, and those with a geographic pattern  
```{r, fig.height=5, fig.width=9}

group <- "Organobromines"

# Get positions for km's to show:
points <- c(0, 500, 1000, 1500, 2000, 2500, 2685) %>% map_df(~get_point_on_coastline(.))

gg1 <- plotvalues_gamm_med %>%
  # Pick data
  filter(Substance.Group %in% group &
           TISSUE_NAME %in% "Lever"
           ) %>% 
  # Add 'Position_p' (p-values) to data
  left_join(ttable_gamm %>% select(PARAM, TISSUE_NAME, Position_p), 
            by = c("PARAM", "TISSUE_NAME")) %>%
  mutate(Significant = ifelse(Position_p < 0.05, "Significant", "Not significant")) %>%
  # Find mean value (next 3 lines)
  group_by(PARAM) %>%
  mutate(mean_value = mean(visregFit)) %>%
  ungroup() %>%
  # Pick only the most common parameters (next 4 lines)
  filter(mean_value > (-0.8) & Significant == "Significant") %>%
  # Set factors in order following mean_value
  mutate(PARAM = forcats::fct_reorder(PARAM, mean_value, .desc = TRUE)) %>%
  # Plot
  ggplot(aes(Dist_along_coast, visregFit, color = PARAM)) + 
  geom_line(size = rel(1)) + 
  geom_vline(data = points, 
             aes(xintercept = distance),
             linetype = "dashed") +  
  annotate("vline", xintercept = points$distance) +
  labs(x = "Distance along coast", y = "log(Concentration in cod liver)") +
  theme_bw() 

# Direction of text labels:
points$Text_direction <- "West"
points$Text_direction[c(1,6,7)] <- "East"

# PLot
gg2 <- ggplot(mapdata, aes(x, y)) +
  geom_path() +
  coord_fixed() +
  geom_path(data = coast, color = "red") +
  geom_point(data = points, color = "blue") +
  geom_text(data = points %>% filter(Text_direction == "West"), 
            aes(x = x - 20000, label = paste(distance, "km")), color = "blue", hjust = 1, size = rel(3)) +
  geom_text(data = points %>% filter(Text_direction == "East"), 
            aes(x = x + 20000, label = paste(distance, "km")), color = "blue", hjust = 0, size = rel(3)) +
  expand_limits(x = c(min(mapdata$x, na.rm = TRUE) - 150000,
                      max(mapdata$x, na.rm = TRUE) + 200000)) +
  theme_minimal() +
  theme(
    axis.text = element_blank(),
    axis.title = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank()
  )

cowplot::plot_grid(gg1, gg2, nrow = 1, rel_widths = c(2, 1))
  
```


## 9. Combine linear + non-linear results in table  

### Combine tables  
```{r, fig.width=9, fig.height=9}

# linear_results

# OLD - some error with cell spec results oin cells that look like this:
# <span style=" color: black !important;" >Metals and metalloids</span>

#
# tab1 <- linear_results %>%
#   filter(TISSUE_NAME %in% "Lever" & !is.na(Position_est)) %>%
#   select(PARAM, TISSUE_NAME, Position_est, Position_p) %>%
#   group_by(PARAM, TISSUE_NAME) %>%
#   summarise_all(list(min = min, mean = mean, median = median)) %>%
#   ungroup() %>%
#   mutate(Linear_effect = case_when(
#     is.na(Position_est_mean) ~ "-",
#     Position_est_mean < 0 ~ "Decreasing",
#     Position_est_mean >= 0 ~ "Increasing"),
#     Linear_p = case_when(
#       is.na(Position_p_median) ~ "-",
#       Position_p_median < 0.001 ~ "< 0.001",
#       Position_p_median < 0.01 ~ round(Position_p_median, 3) %>% as.character(),
#       Position_p_median <= 1 ~ round(Position_p_median, 2) %>% as.character()),
#     Linear_p = cell_spec(
#       Linear_p, "html", 
#       color = ifelse(Position_p_median < 0.05, "red", "black"))
#     ) %>% 
#   select(PARAM, TISSUE_NAME, Linear_effect, Linear_p)

tab1 <- linear_results %>%
  filter(TISSUE_NAME %in% "Lever" & !is.na(Position_est)) %>%
  select(PARAM, TISSUE_NAME, Position_est, Position_p) %>%
  group_by(PARAM, TISSUE_NAME) %>%
  summarise_all(list(min = min, mean = mean, median = median)) %>%
  ungroup() %>%
  mutate(Linear_effect = case_when(
    is.na(Position_est_mean) ~ "-",
    Position_est_mean < 0 ~ "Decreasing",
    Position_est_mean >= 0 ~ "Increasing"),
    Linear_p = case_when(
      is.na(Position_p_median) ~ "-",
      Position_p_median < 0.001 ~ "< 0.001",
      Position_p_median < 0.01 ~ round(Position_p_median, 3) %>% as.character(),
      Position_p_median <= 1 ~ round(Position_p_median, 2) %>% as.character())
    ) %>% 
  select(PARAM, TISSUE_NAME, Linear_effect, Linear_p)


# tab1


# non-linear results

# OLD - some error with cell spec
#
# tab2 <- ttable_gamm %>%
#   group_by(PARAM, TISSUE_NAME) %>%
#   summarise_at(vars(Position_esdf, Position_p), median) %>%
#   mutate(Non_linear_df = round(Position_esdf, 2), 
#     Non_linear_p = case_when(
#       is.na(Position_p) ~ "-",
#       Position_p < 0.001 ~ "< 0.001",
#       Position_p < 0.01 ~ round(Position_p, 3) %>% as.character(),
#       Position_p <= 1 ~ round(Position_p, 2) %>% as.character()),
#     Non_linear_p = cell_spec(
#       Non_linear_p, "html", 
#       color = ifelse(!is.na(Position_p) & Position_p < 0.05, "red", "black"))
#     ) %>% 
#   select(PARAM, TISSUE_NAME, Non_linear_df, Non_linear_p)

tab2 <- ttable_gamm %>%
  group_by(PARAM, TISSUE_NAME) %>%
  summarise_at(vars(Position_esdf, Position_p), median) %>%
  mutate(Non_linear_df = round(Position_esdf, 2), 
    Non_linear_p = case_when(
      is.na(Position_p) ~ "-",
      Position_p < 0.001 ~ "< 0.001",
      Position_p < 0.01 ~ round(Position_p, 3) %>% as.character(),
      Position_p <= 1 ~ round(Position_p, 2) %>% as.character())
    ) %>% 
  select(PARAM, TISSUE_NAME, Non_linear_df, Non_linear_p)


# Combine:

# OLD - some error with cell_spec
#
# tab_comb <- left_join(tab1, tab2, by = c("PARAM", "TISSUE_NAME")) %>%
#     # Add substance group
#   left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
#             by = c("PARAM" = "Parameter.Code")) %>%
#   select(Substance.Group, everything()) %>%
#   arrange(Substance.Group, PARAM) %>%
#   mutate(
#     Substance.Group = cell_spec(Substance.Group, "html", color = "black"),
#         PARAM = cell_spec(PARAM, "html", color = "black"),
#         TISSUE_NAME = cell_spec(TISSUE_NAME, "html", color = "black"),
#         Linear_effect = cell_spec(Linear_effect, "html", color = "black"),
#         Non_linear_df = cell_spec(Non_linear_df, "html", color = "black")
#     )

tab_comb <- left_join(tab1, tab2, by = c("PARAM", "TISSUE_NAME")) %>%
    # Add substance group
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code")) %>%
  select(Substance.Group, everything()) %>%
  arrange(Substance.Group, PARAM)

  
# cell_spec("makan", "html", color = "red")
```

### Order variables  
```{r}

pars_pcb <- tab_comb %>% 
  filter(Substance.Group %in% "Chlorobiphenyls") %>%
  pull(PARAM) %>%
  sort_by_number() %>%
  move_to_back("CB")

pars_bde <- tab_comb$PARAM %>% grep("^BD", ., value = TRUE) %>%
  sort_by_number()

pars_hbcd <- tab_comb$PARAM %>% grep("HBCD", ., value = TRUE) %>%
  sort() %>%
  move_to_front("Sum HBCD")

pars_pfas <- tab_comb %>% 
  filter(Substance.Group %in% "Organofluorines") %>%
  pull(PARAM) %>% 
  move_to_front("PFAS$")  # since this is the sum  

# Show all, for check  
pars_pcb
pars_bde
pars_hbcd
pars_pfas

# Other parameters, in alphabetic order 
par_all <- tab_comb %>% pull(PARAM)
sel1 <- par_all %in% pars_pcb
sel2 <- par_all %in% pars_bde
sel3 <- par_all %in% pars_hbcd
sel4 <- par_all %in% pars_pfas
pars_other <- par_all[!(sel1 | sel2 | sel3 | sel4)]

# Correct order
par_levels <- c(pars_pcb, pars_bde, pars_hbcd, pars_pfas, pars_other)

# Check if some parameters occur more than once (they shouldn't!):
check <- table(par_levels)
if (sum(check > 1) > 0)
  check[check > 1]


# Set PARAM factor levels in correct order
tab_comb <- tab_comb %>%
  mutate(PARAM = factor(PARAM, levels = par_levels))

```

### Show table  
```{r, fig.width=11, fig.height=9}

# Must fix problem with cell_spec, see above
if (FALSE){
  kabletab <- kable(tab_comb %>% 
                      arrange(Substance.Group, PARAM),
                    format = "html", escape = FALSE) %>%
    kable_styling(bootstrap_options = "condensed")
  
  kabletab
}


kable(tab_comb)


#
# Tried to use pack_rows - gave up, perhaps retry later   
#
# for (category in group_order){
#   sel <- tab_comb$Substance.Group %in% category
#   if (sum(sel) > 0){
#     i <- which(sel) %>% range()
#     kabletab <- kabletab %>% pack_rows(category, i[1], i[2])
#   }
# }

```



## 10. GAMM with interaction  

### Test functions     
Functions named as functions above, with '_int' added, i.e.,  
- run_gamm_model_int  
- run_gamm_extract_results_int  
- run_gamm_int
```{r, fig.width = 8, fig.height=3.5}

# debugonce(run_gamm_model_int)
# debugonce(run_gamm_extract_results_int)
z <- run_gamm_int(dat_param2, repl = 1)
str(z, 1)
ggplot(z$plotvalues, aes(Dist_along_coast, visregFit, group = MYEAR, color = MYEAR)) + geom_line()


```


### Test 'gamm_one_par_one_repl'  
Function defined in part 7, we just use interaction = TRUE instead of the default   
```{r}

x1 <- gamm_one_par_one_repl("NI", "Whole soft body", dat2, interaction = TRUE)

# debugonce(run_gamm_extract_results_int)
x2 <- gamm_one_par_one_repl("PFUdA", "Lever", dat2, interaction = TRUE)

ggplot(x1$plotvalues, aes(Dist_along_coast, visregFit, group = MYEAR, color = MYEAR)) + geom_line()
ggplot(x2$plotvalues, aes(Dist_along_coast, visregFit, group = MYEAR, color = MYEAR)) + geom_line()

# Show t values
list(x1, x2) %>% map_dfr(~.$anova)


```

### Run for all parameters and replicates

#### Test   
Defining 'listno_replicate'  and using 'series_param_tissue' defined in part 5 (' Select time series')  
Two parameters only  
```{r}

if (FALSE){ 
  
  # 1:nrow(series_param_tissue) %>%
  
  nrow <- 2  # number of parameters/tissues
  nrep <- 2  # number of replicates
  
  # Data frame with two columns, col. 1 for parameter/tissue, col. 2 for replicate  
  listno_replicate <- data.frame(
    listno = rep(1:nrow, each = nrep),
    replicate = rep(1:nrep, nrow)
  )
  nrow(listno_replicate)  # 4
  
  # GAM analyses  
  x <- 1:nrow(listno_replicate) %>%
    map(
      ~gamm_one_par_one_repl(
        series_param_tissue$PARAM[listno_replicate$listno[.]], 
        series_param_tissue$TISSUE_NAME[listno_replicate$listno[.]],
        repl = listno_replicate$listno[.],
        data = dat2,
        interaction = TRUE)
    )
  
  str(x, 1)            # list of 4 lists
  str(x[[1]], 1)       # list of 2, anova and plotvalues
  
}


```

#### All parameters/tissues  
Is only run if 'run_analysis' = TRUE, otherwise we use saved data   
```{r}

# Safe version
gamm_one_par_one_repl_s <- safely(gamm_one_par_one_repl)

# Set up
nrow <- nrow(series_param_tissue)  # number of parameters/tissues
nrep <- 3                          # number of replicates

# Set up data frame with two columns, col. 1 for parameter/tissue, col. 2 for replicate  
listno_replicate <- data.frame(
  listno = rep(1:nrow, each = nrep),
  replicate = rep(1:nrep, nrow)
)
cat("Length of listno_replicate: \n")
nrow(listno_replicate)  # 1014



#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o
#
# Set this to TRUE to recalculate all annalyses
#
# If FALSE, saved results are used  
#
#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o
run_analysis <- FALSE  
# run_analysis <- TRUE  


if (run_analysis) {
  
  # For taking the time 
  t0 <- Sys.time()
  
  # GAM analyses  
  gamm_list <- 1:nrow(listno_replicate) %>%
    map(
      ~gamm_one_par_one_repl_s(
        series_param_tissue$PARAM[listno_replicate$listno[.]], 
        series_param_tissue$TISSUE_NAME[listno_replicate$listno[.]],
        repl = listno_replicate$replicate[.],
        data = dat2,
        interaction = TRUE)
    ) %>%
    purrr::transpose()
  
  # For takng the time 
  t1 <- Sys.time()
  t1-t0     # 1.27 hours
  
  # Only done once, when we have run the entire analysis  
  saveRDS(gamm_list, "Data/121_gamm_list_notimpacted_int.rds")
  
} else {

  # Use the saved results
  gamm_list <- readRDS("Data/121_gamm_list_notimpacted_int.rds")
  
}

cat("\n gamm_list: \n")
str(gamm_list, 1)              # list of 2 lists, "result" and "error"

cat("\n gamm_list$result: \n")
length(gamm_list$result)       # list of 555
str(gamm_list$result[[1]], 1)  # list of 2 data frames, ttable (1 row) and plotvalues (101 rows)

```


## 11. GAMM with interaction, results  

### Get analyses that didn't fail  

```{r}

cat("Number of regressions that worked (numbers / fraction): \n")
ok <- gamm_list[["error"]] %>% map_lgl(is.null)
sum(ok)
mean(ok)  # 0.52

# Save "ok" in data frame used to run analysis
# listno_replicate$Result_ok <- ok

if (FALSE){
  i <- grep("Heptaklorepoksid", series_param_tissue$PARAM)
  j <- which(listno_replicate$listno %in% i)
  ok[j]
}

```


### Extract ANOVA values and plot values (fitted lines)  
- t-values: ttable_gamm  
- Also take the median fitted lines (across replicates): plotvalues_gamm_med     
- Also add 'Substance.Group' for both    
```{r, warning=FALSE, results='hide', message=FALSE}

# Extract the one-line t-tables and combine
anova_gamm <- gamm_list[["result"]][ok] %>% 
  map_dfr(~.[["anova"]]) %>%
  # Add substance group
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code"))

# Extract the line fits for the "Positopn" effects  
plotvalues_gamm <- gamm_list[["result"]][ok] %>% 
  map_dfr(~.[["plotvalues"]])

# Median fitted lines (across replicates)
plotvalues_gamm_med <- plotvalues_gamm %>%
  group_by(PARAM, TISSUE_NAME, MYEAR, Dist_along_coast) %>%      # difference from 8: added MYEAR here
    summarise_at(
    vars(visregFit, visregLwr, visregUpr),
    median) %>%
  # Add substance group
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code"))

# Check 'plotvalues_gamm' and 'plotvalues_gamm_med' for 
#   a parameter with many <LOQ values (BAP)
if (FALSE){
  
  plotvalues_gamm %>%
    filter(PARAM == "AS" & TISSUE_NAME == "Lever") %>%
    ggplot(aes(Dist_along_coast, visregFit)) + 
    geom_path(aes(group = MYEAR, color = MYEAR), size = 1) +
    geom_path(
      data = plotvalues_gamm_med %>% filter(PARAM == "AS"),
      aes(Dist_along_coast, visregFit),
      linetype = 2
    )
  
}

```

### Check p-values and AIC      

#### Summarize over replicates  
We keep both median and max (conservative) values
```{r}

anova_gamm_summ <- anova_gamm %>%
  group_by(Substance.Group, PARAM, TISSUE_NAME) %>%      # difference from 8: added MYEAR here
  summarise_at(vars(dAIC, p_value), list(median=median, max = max))  

```


#### Overall patterns   
Median and max values largely agrees, and so does dAIC and p-values  
```{r}

cat("Median vs max values of p-values (limit = 0.05): \n")
xtabs(~(p_value_median < 0.05) + (p_value_max < 0.05), anova_gamm_summ)

cat("\n")
cat("Median vs max values of p-values (limit = -1): \n")
xtabs(~(dAIC_median < -1) + (dAIC_max < -1), anova_gamm_summ)

cat("\n")
cat("dAIC vs p-values: \n" )
xtabs(~(dAIC_max < -1) + (p_value_max < 0.05), anova_gamm_summ)

```

#### Significance of interaction  
Cod liver and mussels, resp.  
```{r}

tissues <- c("Lever", "Whole soft body")

for (tissue in tissues){
  anova_gamm_summ %>%
    filter(TISSUE_NAME == tissue) %>%
    mutate(
      Substance.Group = cell_spec(
        substr(Substance.Group, 1, 28), "html",
        color = "black"
      ), 
      dAIC_max = cell_spec(
        round(dAIC_max, 3), "html",
        color = ifelse(dAIC_max < -1, "red", "black")
      ),
      p_value_max = cell_spec(
        format_p(p_value_max), "html",
        color = ifelse(p_value_max < 0.05, "red", "black")
      )
    ) %>%
    select(Substance.Group, PARAM, dAIC_max, p_value_max) %>%
    knitr::kable(format = "html", escape = FALSE) %>%
    kableExtra::kable_styling(bootstrap_options = "condensed") %>%
    add_header_above(setNames(4, tissue), font_size = 15) %>%
    print()
}


```

### Plots of effects    
Test  
```{r}

plotvalues_gamm_med %>%
  filter(PARAM == "CD" & TISSUE_NAME == "Lever") %>%
  ggplot(aes(Dist_along_coast, visregFit, group = MYEAR)) +
    geom_ribbon(aes(ymin = visregLwr, ymax = visregUpr), alpha = 0.5) +
    geom_line(aes(color = MYEAR))

cols <- RColorBrewer::brewer.pal(n = 7, name = "BuGn")[3:7]
cols <- RColorBrewer::brewer.pal(n = 7, name = "BrBG")[c(1,2,6,7)]

plotvalues_gamm_med %>%
  filter(PARAM == "CD" & TISSUE_NAME == "Lever") %>%
  ggplot(aes(Dist_along_coast, visregFit, group = MYEAR, color = MYEAR)) +
  geom_line(size = 1) +
  scale_color_manual(values = cols)
  

```

Plot a selection of substances  
```{r, fig.width=5, fig.height=3}

cols <- RColorBrewer::brewer.pal(n = 7, name = "BrBG")[c(1,2,6,7)]

params <- c(
  "BDE99, BDE47, BDESS, ZN, AG, CD, CU, CB118, CB52, CB_S7" %>% strsplit(", ") %>% .[[1]],
  "DDEPP, DDTPP, PFAS, PFOS, PFOA, PFDcA, Toksafen Parlar 50, HCHB, Aldrin" %>% strsplit(", ") %>% .[[1]]
)
# params

for (param in params){
  df <- plotvalues_gamm_med %>%
    filter(PARAM == param & TISSUE_NAME == "Lever")
  if (nrow(df) > 0){
    gg <- ggplot(df, aes(Dist_along_coast, visregFit, group = MYEAR, color = MYEAR)) +
      geom_line(size = 1) +
      scale_color_manual(values = cols) +
      labs(title = param)
    print(gg)
  }
}

```



