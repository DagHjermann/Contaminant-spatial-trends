---
title: "Spatial patterns of contaminants"
author: "DHJ"
date: "6 5 2020"
output: 
  html_document:
    keep_md: true
    toc: true
    toc_float: true  
    code_folding: hide  
---

Script 122, based on script 120   


## 1. Libraries  
```{r, message=FALSE, warning=FALSE, results='hide'}


library(rlang)

library(devtools)
library(lme4)
library(usethis)
library(dplyr)
library(tidyr)
library(purrr)
library(forcats)
library(ggplot2)
library(mgcv)
library(visreg)

# devtools::install_github("moodymudskipper/safejoin")
library(safejoin)

# devtools::install_github("lenz99-/lme4cens")
library(lme4cens)

# For SpatialPoints() function in part 2, used for map in part 8
library(sp)

# For combining plots
library(cowplot)

# For nicer tables
library(knitr)
library(kableExtra)

# For get_point_on_coastline()
# Used in part 8  
source("103_Distance_along_coast_functions.R")
source("121_Analysis_01_functions.R")
source("122_Analysis_01_plots_functions.R")


```


## 2. Data   
```{r}
#
# Note that we get stations from script 103  
#

# Data including trophic level
dat <- readRDS("Data/104_Selected_data.rds")
cat("Main data set has", nrow(dat), "number of records \n")

# Extra isotope data
dat_isotopes <- readRDS("Input_data/87_df_isotopes.rds")

# Station metadata
df_stations <- readRDS("Data/103_Selected_stations.rds")




# xtabs(~STATION_CODE, df_stations ) %>% sort()
df_stations <- df_stations %>%
  mutate(MSTAT = case_when(
    STATION_CODE %in% "I969" ~ "RH",
    TRUE ~ MSTAT)) %>%
  group_by(STATION_CODE, MSTAT) %>%
  summarise_at(vars("Lat", "Lon", "Dist_along_coast"), mean)

check <- df_stations %>%
  group_by(STATION_CODE) %>%
  mutate(n = n()) %>%
  filter(n > 1)

if (nrow(check) > 0){
  cat("Some stations have >1 MSTAT codes - check 'check'! \n")
}
  
```
Adding   
* position data + MSTAT (type of station - industry-impacted, representative or background)   
* LOQ   
* mean trophic level per station    
```{r, results='hold'}
#
# Copied from script 121
#

# Median LOQ (per year and tissue only - should be the same for all stations)
dat_param_loq <- dat %>%
  filter(!is.na(FLAG1)) %>%
  group_by(PARAM, MYEAR, TISSUE_NAME) %>%
  summarise(LOQ = median(VALUE_WW), .groups = "drop")

dat2 <- dat %>%
  filter(!is.na(VALUE_WW)) %>%
  ungroup() %>%
  # Add position data + MSTAT (type of station - industry-impacted, representative or background)
  safe_left_join(df_stations %>% 
                   select(STATION_CODE, Lat, Lon, Dist_along_coast, MSTAT),
                 check = "CV",
                 by = "STATION_CODE",
                 na_matches = "never") %>%
  # Add LOQ
  safe_left_join(dat_param_loq,
                 check = "CV",
                 by = c("PARAM", "MYEAR", "TISSUE_NAME"),
                 na_matches = "never") %>%
  mutate(MSTAT = factor(MSTAT,  levels = c("IH", "RH", "B"))) %>%
  # Add mean trophic level per station
  group_by(STATION_CODE) %>%
  mutate(TL_mean = mean(TL, na.rm = TRUE)) %>%
  ungroup() %>%
  filter(!is.na(Dist_along_coast))

# dat2 <- dat

```
Make data set with non-impacted stations only    
```{r}

dat2_notimpacted <- dat2 %>%
  # Only difference from the next: using 'df_param_notimpacted' here:
  filter(!MSTAT %in% "IH") %>% 
  as.data.frame()

```


Load data for plotting maps    
```{r}

# From script 103 (without adaption)      

#
# Get Norway map data
#
test <- maps::map("world", "Norway", plot = FALSE)   # map data for Norway - this is just to get region names
sel <- grepl("Svalbard", test$names) | test$names == "Norway:Jan Mayen"  # select Svalbard + Jan Mayen
# test$names[!sel]
map <- maps::map("world", test$names[!sel], exact = TRUE, plot = FALSE)  # Norway w/o Svalbard + Jan Mayen
mapdata <- data.frame(Longitude = map$x, Latitude = map$y)

#
# Add UTM coordinates (x and y) to map
#
coordinate_exists <- !is.na(mapdata$Longitude)   # sp doesn't like NAs
SP <- sp::SpatialPoints(mapdata[coordinate_exists, c("Longitude", "Latitude")],
                    proj4string=CRS(crs_longlat)
)
SP.UTM <- sp::spTransform(SP, CRS(crs_utm))
# Add transformed coords to data set
mapdata$x[coordinate_exists] <- SP.UTM@coords[,1]
mapdata$y[coordinate_exists] <- SP.UTM@coords[,2]


#
# "Coast" data (coordinates for segments along the coast)
#
coast <- readRDS("Data/102_coast_coordinates.rmd")

#
# Make 'coastsegment_distance'   
#
# Distances for start points of the coast segments
segment_dx <- diff(coast$x)/1000
segment_dy <- diff(coast$y)/1000
coastsegment_distance <- sqrt(segment_dx^2 + segment_dy^2) %>% cumsum()
coastsegment_distance <- c(0, coastsegment_distance)


```

### MSTAT categorisation     
MSTAT categories:    
* IH = industry-impacted  
* RH = representative  
* B = background    
Tables shows number of years of data    
```{r}

dat2 %>%
  filter(grepl("B", STATION_CODE)) %>%
  distinct(STATION_CODE, MSTAT, MYEAR) %>%
  xtabs(~ STATION_CODE + MSTAT, .) %>%
  kbl(escape = FALSE) %>%
  kable_paper("basic", full_width = FALSE)

```

### Parameter groups  
```{r}

df_parameter_groups <- get_df_parameter_groups()

df_parameter_groups %>%
  count(Substance.Group) %>%
  kbl(caption = "Number of parameters per group", escape = FALSE) %>%
  kable_paper("basic", full_width = FALSE)

```





## 3. Non-linear analyses (GAMM)     
Note:  
* These analyses were performed for all unimpacted stations    
* For concentrations under LOQ, we used random numbers between LOQ/2 and LOQ (3 replicates)  
```{r}

#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o
# Load results from script 104  
#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o#o

# Use the saved results
gamm_list <- readRDS("Data/121_gamm_list1.rds")
cat("Results for", length(gamm_list[[1]]), "parameters/tissues loaded")

if (FALSE){
  str(gamm_list, 1)
  length(gamm_list[["result"]])
  str(gamm_list[["result"]][[1]], 1)
  str(gamm_list[["result"]][[1]]$plotvalues, 1)
  gamm_list[["result"]][[1]][["ttable"]]
  str(gamm_list[["error"]][[1]], 1)
}

```



### Check GAMM results  

Get analyses that didn't fail  
```{r, results='hold'}

cat("Number of regressions that worked (numbers / percentage): \n")
ok <- gamm_list[["error"]] %>% map_lgl(is.null)
sum(ok)
mean(ok)*100  # 0.96

# Save "ok" in data frame used to run analysis
# listno_replicate$Result_ok <- ok

```
Extract t-values and plot values (fitted lines)   
```{r, warning=FALSE, results='hide', message=FALSE}

#
# - t-values: ttable_gamm  
# - Also take the median fitted lines (across replicates): plotvalues_gamm_med     
# - Also add 'Substance.Group' for both    
#

# Extract the one-line t-tables and combine
ttable_gamm <- gamm_list[["result"]][ok] %>% 
  map_dfr(~.[["ttable"]]) %>%
  # Add substance group
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code"))
cat("t and p values for", nrow(ttable_gamm), "parameters/stations \n")

# All numbers are character, set to numeric
vars <- c("Repl", 
          "Year_edf", "Position_esdf", "Year_F", 
          "Position_F", "Year_p", "Position_p")
for (var in vars)
  ttable_gamm[[var]] <- as.numeric(ttable_gamm[[var]])

# Extract the line fits for the "Positopn" effects  
plotvalues_gamm <- gamm_list[["result"]][ok] %>% 
  map_dfr(~.[["plotvalues"]])

# Median fitted lines (across replicates)
plotvalues_gamm_med <- plotvalues_gamm %>%
  group_by(PARAM, TISSUE_NAME, Dist_along_coast) %>%
    summarise_at(
    vars(visregFit, visregLwr, visregUpr),
    median) %>%
  # Add substance group
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code"))


# Check 'plotvalues_gamm' and 'plotvalues_gamm_med' for 
#   a parameter with many <LOQ values (BAP)
if (FALSE){
plotvalues_gamm %>%
  filter(PARAM == "BAP") %>%
  # We cheat a bit to recreate how Repl should actually be (because of code error; now fixed):
  mutate(Repl = rep(1:3, each = 101)) %>%   # xtabs(~TISSUE_NAME + Repl, .) 
  ggplot(aes(Dist_along_coast, visregFit)) + 
  geom_path(aes(color = factor(Repl)), size = 2) +
  geom_path(
    data = plotvalues_gamm_med %>% filter(PARAM == "BAP"),
    aes(Dist_along_coast, visregFit),
    linetype = 2
  )
}

```


### p-values for the effect of 'distance along coast' on concentration         
```{r}

ttable_gamm %>%
  filter(TISSUE_NAME %in% "Lever") %>%
  mutate(
    `Effect of distance along coast` = ifelse(Position_p < 0.05, "P <= 0.05", "P > 0.05")
  ) %>%
  xtabs(~ addNA(Substance.Group) + `Effect of distance along coast`, .,
        drop.unused.levels = TRUE)


if (FALSE){


  ttable_gamm %>%
    ggplot(aes(Position_p)) + geom_histogram()

  # fit's degrees of freedom > 1 means non-linear fit  
  ttable_gamm %>%
    ggplot(aes(Position_p, Position_esdf)) + geom_point()
  
  ttable_gamm %>%
    xtabs(~(Position_p < 0.05) + (Position_esdf > 1), .)
  
  ttable_gamm %>%
    xtabs(~ addNA(Substance.Group) + (Position_p < 0.05) + TISSUE_NAME, .)
  
}

# for checking
if (FALSE){
  ttable_gamm %>%
    filter(is.na(Substance.Group)) %>%
    xtabs(~PARAM, .) %>%
    names() %>%
    paste(collapse = ";")
}


```




## 4. Parameters with significant geographic effect (per group) {.tabset}   
Note: For unimpaced stations (RH and B stations)  
  
### Organobromines  
```{r, fig.height=5, fig.width=9}
plotgamm_group("Organobromines", report = FALSE)
```


### Metals  
```{r, fig.height=5, fig.width=9}
plotgamm_group("Metals", minvalue = -2, report = FALSE)
```


### Chlorobiphenyls     
```{r, fig.height=5, fig.width=9}
plotgamm_group("Chlorobiphenyls", minvalue = -1)
```

### DDT  
```{r, fig.height=5, fig.width=9}
plotgamm_group("DDT", minvalue = -1)
```


## 5. Examples {.tabset}   
* The "tile" plots show raw data (medians per station/year) for all stations  
* The two "model" plots show estimated effects for length- and fat-adjusted data for unimpacted stations   

### BDE47  
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}  
# debugonce(plot_observations)
plot_observations("BDE47")  
```
  
### BDE99  
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("BDE99")  
```
### ZN    
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("ZN")  
```
  
### AG    
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("AG")  
```
### CU    
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("CU")  
```
  
### HG  
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("HG", "Muskel")  
```
  
### Sum PCB    
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("CB_S7")  
```

### CB118      
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("CB118")  
```

### Pentaklorbenzen      
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("QCB")  
dat %>% filter(grepl("QCB", PARAM))
```

### DDEPP      
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
# debugonce(plot_observations)
plot_observations("DDEPP")   
```

### MCCP      
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("MCCP")   
```
### PFOS      
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("PFOS")   
```

### PFOSA      
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("PFOSA")   
```

### PFOSA      
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("PFOSA")   
```

### Toksafen Parlar 50       
```{r, fig.width=7, fig.height=4, warning=FALSE, message=FALSE}
plot_observations("Toksafen Parlar 50")   
```

## 6. Linear results   
Different from the non-linear (GAMM) statistics by  
* Assumin a linear effect of distance along coast  
* Analysing length-adjusted concentrations (instead of raw wet-weight concentrations)   
* Picking either 

```{r}

result_list <- readRDS("Data/120_result_list_notimpacted.rds")

```


### Summary of results  
```{r}

```



### Linear_results - store result as 'linear_results'   
*See combined table below for results*
```{r, results='hold'}

ok <- result_list[[2]] %>% map_lgl(is.null)
cat("Number of regressions that worked (numbers / fraction): \n")
sum(ok)
mean(ok)

# series_param_tissue$Result_nonimpact <- ok

linear_results <- result_list[[1]][ok] %>% 
  bind_rows() %>% 
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code"),
            na_matches = "never") %>%
  select(Substance.Group, everything()) %>%
  arrange(Substance.Group)

```


## 7. Combine linear + non-linear results in table  

Combine tables  
```{r, fig.width=9, fig.height=9}

# linear_results

tab1 <- linear_results %>%
  filter(TISSUE_NAME %in% "Lever" & !is.na(Position_est)) %>%
  select(PARAM, TISSUE_NAME, Position_est, Position_p) %>%
  group_by(PARAM, TISSUE_NAME) %>%
  summarise_all(list(min = min, mean = mean, median = median)) %>%
  ungroup() %>%
  mutate(Linear_effect = case_when(
    is.na(Position_est_mean) ~ "-",
    Position_est_mean < 0 ~ "Decreasing",
    Position_est_mean >= 0 ~ "Increasing"),
    Linear_p = case_when(
      is.na(Position_p_median) ~ "-",
      Position_p_median < 0.001 ~ "< 0.001",
      Position_p_median < 0.01 ~ round(Position_p_median, 3) %>% as.character(),
      Position_p_median <= 1 ~ round(Position_p_median, 2) %>% as.character())
    ) %>% 
  select(PARAM, TISSUE_NAME, Linear_effect, Linear_p)


# tab1


tab2 <- ttable_gamm %>%
  mutate(across(c(Year_edf, Position_esdf, Year_F, Position_F, Year_p, Position_p), as.numeric)) %>%
  group_by(PARAM, TISSUE_NAME) %>%
  summarise_at(vars(Position_esdf, Position_p), median) %>%
  mutate(Non_linear_df = round(Position_esdf, 2), 
    Non_linear_p = case_when(
      is.na(Position_p) ~ "-",
      Position_p < 0.001 ~ "< 0.001",
      Position_p < 0.01 ~ round(Position_p, 3) %>% as.character(),
      Position_p <= 1 ~ round(Position_p, 2) %>% as.character())
    ) %>% 
  select(PARAM, TISSUE_NAME, Non_linear_df, Non_linear_p)


# Combine:


tab_comb <- left_join(tab1, tab2, by = c("PARAM", "TISSUE_NAME")) %>%
    # Add substance group
  left_join(df_parameter_groups[c("Parameter.Code", "Substance.Group")],
            by = c("PARAM" = "Parameter.Code")) %>%
  select(Substance.Group, everything()) %>%
  arrange(Substance.Group, PARAM)

  
# cell_spec("makan", "html", color = "red")
```

Order variables  
```{r, results='hide'}
pars_pcb <- tab_comb %>% 
  filter(Substance.Group %in% "Chlorobiphenyls") %>%
  pull(PARAM) %>%
  sort_by_number() %>%
  move_to_back("CB")

pars_bde <- tab_comb$PARAM %>% grep("^BD", ., value = TRUE) %>%
  sort_by_number()

pars_hbcd <- tab_comb$PARAM %>% grep("HBCD", ., value = TRUE) %>%
  sort() %>%
  move_to_front("Sum HBCD")

pars_pfas <- tab_comb %>% 
  filter(Substance.Group %in% "Organofluorines") %>%
  pull(PARAM) %>% 
  move_to_front("PFAS$")  # since this is the sum  

# Show all, for check  
pars_pcb
pars_bde
pars_hbcd
pars_pfas

# Other parameters, in alphabetic order 
par_all <- tab_comb %>% pull(PARAM)
sel1 <- par_all %in% pars_pcb
sel2 <- par_all %in% pars_bde
sel3 <- par_all %in% pars_hbcd
sel4 <- par_all %in% pars_pfas
pars_other <- par_all[!(sel1 | sel2 | sel3 | sel4)]

# Correct order
par_levels <- c(pars_pcb, pars_bde, pars_hbcd, pars_pfas, pars_other)

# Check if some parameters occur more than once (they shouldn't!):
check <- table(par_levels)
if (sum(check > 1) > 0)
  check[check > 1]

# Set PARAM factor levels in correct order
tab_comb <- tab_comb %>%
  mutate(PARAM = factor(PARAM, levels = par_levels))

```

```{r}
cs_dt <- tab_comb

cs_dt$Linear_p = cell_spec(cs_dt$Linear_p, 
                           color = ifelse(cs_dt$Linear_p < 0.05, "red", "black"))

cs_dt$Non_linear_p = cell_spec(cs_dt$Non_linear_p, 
                               color = case_when(
                                 is.na(cs_dt$Non_linear_p) ~ "black",
                                 cs_dt$Non_linear_p <= 0.05 ~ "red",
                                 cs_dt$Non_linear_p > 0.05 ~ "black")
                               )


kbl(cs_dt, escape = F) %>%
  kable_paper("striped", full_width = F)

```










